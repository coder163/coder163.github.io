
#### 1. 线程之间共享什么数据

首先，值得确切知道每个进程和每个线程存储的状态。每个线程都有自己的程序计数器和处理器状态。这意味着线程通过代码独立进行。每个线程也有自己的堆栈，因此局部变量本身就是每个线程的本地变量，并且这些变量不存在同步问题。程序中的全局数据可以在线程之间自由共享，因此这些变量可能存在同步问题。当然，如果变量是全局可访问的，但只有一个线程使用它，则没有问题。同样的情况适用于在堆上分配的内存（通常是对象）：原则上，任何线程都可以访问特定对象，但是如果编写程序使得只有一个线程具有指向特定对象的指针

Delphi提供了threadvar关键字。这允许声明“全局”变量，其中为每个线程创建变量的副本。此功能使用不多，因为将这些变量放在TThread类中通常更方便，因此为每个创建的TThread后代创建一个变量实例。

#### 2. 访问共享数据时的原子性

为了理解如何使线程协同工作，有必要理解原子性的概念。动作一个动作或序列是原子如果动作或序列是不可分割的。当线程执行原子操作时，这意味着所有其他线程将操作视为尚未启动或已完成。一个线程不可能在“行为”中捕获另一个线程。如果线程之间没有执行同步，那么几乎所有操作都是非原子的。我们举一个简单的例子。考虑 这段代码

```pascal
var
  a: integer; {a is global}

begin
  a := a + 1;
end;
```

什么简单？不幸的是，如果两个单独的线程使用它来递增共享变量A，即使是这些微不足道的代码也会导致问题。这个单个pascal语句在汇编程序级别分解为三个操作。

- 从存储器读取A到处理器寄存器。
- 将1添加到处理器寄存器。
- 将处理器寄存器的内容写入内存中的A.

即使在单个处理器机器上，多个线程执行此代码也可能导致问题。之所以这样做是因为调度 操作。当只存在一个处理器时，实际上只有一个线程 一次执行，但Win32调度程序在它们之间以每秒约18次的速度切换。调度程序可以在任何时候停止一个线程运行并启动另一个线程：调度是先发制人的。在挂起一个线程并启动另一个线程之前，操作系统不会等待权限：交换机可能随时发生。由于切换可以在任何两个处理器指令之间发生，因此它可能发生在函数中间的不方便点，甚至是执行一个特定程序语句的一半。让我们假设两个线程正在单处理器机器（X和Y）上执行示例代码。在一个很好的情况下，程序可能正在运行，并且调度操作可能会错过这个临界点，给出预期结果：A增加2。但是，这绝不是保证，而是盲目的机会

如果共享变量碰巧是一个指针，那么人们可以期待各种令人不快的结果。这被称为竞争条件

#### 3. VCL问题

VCL不包含针对这些冲突的保护。这意味着当一个或多个线程正在执行VCL代码时，可能会发生线程切换。很多VCL都包含得很充分，这不是问题。不幸的是，组件，特别是TControl的子组件包含各种机制，这些机制并不适合于线程切换。错误时间的线程切换可能会造成完全破坏，破坏共享句柄的引用计数，不仅会破坏数据，还会破坏组件之间的链接。

即使线程没有执行VCL代码，缺乏同步仍然可能导致进一步的问题：在另一个线程潜入并修改某些内容之前，确保主VCL线程处于休眠状态是不够的。VCL中的某些代码可以执行（例如）弹出对话框，或调用磁盘写入，暂停主线程。如果另一个线程修改了共享数据，则主线程可能会看到一些全局数据由于调用显示对话框或写入文件而神奇地发生了变化。这显然是不可接受的，意味着只有一个线程可以执行VCL代码，或者必须找到一种机制来确保单独的线程不会相互干扰。

#### 4. Delphi解决方案：TThread.Synchronize

Delphi提供了一种解决方案，非常适合初学者进行线程编写。它很简单，克服了迄今为止提到的所有问题。TThread有一个名为**Synchronize**的方法。此方法将您想要执行的另一个无参数方法作为参数。然后保证无参数方法中的代码将作为同步调用的结果执行，并且不会与VCL线程冲突。就调用synchronize的非VCL线程而言，似乎无参数方法中的所有代码都在调用synchronize时发生。

##### 4.1. 这个怎么用？Synchronize有什么作用？

调用synchronize时调用的代码可以执行主VCL线程可能执行的任何操作。此外，它还可以修改与其自己的线程对象相关联的数据，安全地知道其自己的线程的执行位于特定点（同步调用）。实际发生的事情相当优雅，最好用另一个图表说明

![mark](http://p5erjqv72.bkt.clouddn.com/coder16/180928/jBd42l5bHI.png?imageslim)



调用synchronize时，将暂停主计算线程。此时，主VCL线程可以暂停在空闲状态，它可以暂时挂起在I / O或其他操作上，或者它可能正在执行。如果它没有挂起在完全空闲状态（主应用程序消息循环），那么主计算线程会一直等待。一旦主线程变为空闲，传递给synchronize的无参数函数将在主VCL线程的上下文中执行。在我们的例子中，无参数函数称为UpdateResults，并使用备忘录。这确保了主VCL线程不会发生冲突，并且本质上，此代码的处理非常类似于响应于应用程序被发送消息而发生的任何Delphi代码的处理。调用synchronize的线程不会发生冲突，因为它在已知的安全点（TThread.Synchronise的代码中的某处）暂停。
一旦这个“由代理处理”完成，主VCL线程可以自由地进行正常工作，并且恢复调用synchronize的线程，并从函数调用返回。因此，对Synchronize的调用似乎是对主VCL线程的另一个消息，以及对Prime计算线程的函数调用。线程位于已知位置，并且不会同时执行。没有竞争条件。问题解决了。



#### 5. WaitFor方法

如果您以“一劳永逸”的方式使用线程并自动销毁，那么在前一章中讨论的OnTerminate非常有用。如果必须确保在执行VCL线程的某个时刻，所有其他线程都已终止，该怎么办？解决方法是WaitFor方法。如果符合以下条件

- 主VCL线程需要在执行完成后访问工作线程对象，并读取或修改线程中包含的数据。
- 程序关闭时强制终止线程不是一个可行的选择。

很简单，当线程A调用线程B的WaitFor方法时，线程A被挂起，直到线程B完成执行。当线程A恢复时，可以确定可以读取线程B的结果，并且可以销毁表示B的线程对象。通常，这发生在程序终止时，其中主VCL线程将在所有非VCL线程上调用Terminate，然后在退出之前WaitFor所有非VCL线程。


#### 6. WaitFor和Synchronize：死锁简介

WaitFor引发的延迟与其他恶习相比是一个非常小的问题。在同时使用Synchronize和WaitFor的应用程序中，完全可以使应用程序死锁。死锁是一种现象，在应用程序中不会发生算法错误，但整个应用程序停止在水中死亡。在一般情况下，当线程以循环方式彼此等待时发生死锁。线程A可能正在等待线程B完成某些操作，而线程C等待线程D等等。在该行的末尾，线程D可能正在等待线程A完成某些操作。不幸的是，线程A无法完成操作，因为它被挂起。这就是“A：你先走了...... B：不，你...... A：不，我坚持！” 当通行权的所有权不明确时，困扰驾驶者的问题。VCL帮助文件中记录了此行为。

在这种特殊情况下，如果计算线程在主线程调用WaitFor之前不久调用Synchronize，则两个线程之间可能发生死锁。如果发生这种情况，那么计算线程将等待主线程返回消息循环，而主线程正在等待计算线程完成。会导致死锁。主VCL线程也可能在工作线程调用Synchronize之前不久调用WaitFor。鉴于实现过于简单，这也会导致死锁。幸运的是，VCL实现者设法捕获此错误情况，这导致在工作线程中引发异常，从而打破死锁并退出线程

![mark](http://p5erjqv72.bkt.clouddn.com/coder16/180928/eEcgC4faJf.png?imageslim)



