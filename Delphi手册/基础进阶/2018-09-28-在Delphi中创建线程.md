
#### 1. 前言

尽管Win32 API提供了全面的多线程支持，但在创建和销毁线程时，VCL有一个有用的类TThread，它抽象了创建线程的许多技术细节，提供了一些有用的简化，并试图防止程序员陷入这个新学科提供的一些更令人不快的陷阱。我建议使用它。Delphi帮助文件在创建线程类时提供了合理的指导，所以我不会提到创建线程所需的菜单操作序列，除了建议读者选择File | 新建...然后选择“ 线程对象”。

#### 2. 启动问题

Delphi使得线程启动变得容易。在获取子线程执行之前，通常需要在线程中设置一些初始状态。通过创建挂起的线程（构造函数的参数），可以确保线程中的所有代码都不会执行，直到线程恢复为止。这意味着主VCL线程可以安全地读取和修改TThread对象中的数据，并保证在子线程执行时它将被更新并生效。

在该程序的情况下，线程的“FreeOnTerminate”和“TestNumber”属性在线程开始执行之前设置。如果不是这种情况，那么线程的行为将是未定义的。如果您不想创建挂起的线程，那么您只需将启动问题转移到下一个类别：通信问题。

#### 3. 通信问题

当你有两个同时运行的线程，并且你需要以任何方式，形状或形式在它们之间进行通信时，就会发生这种情况。该程序通过在单独的线程之间根本不进行任何通信来避免该问题。在这一点上，我只想说，除非你保护 共享数据的所有操作（对于“保护”的适当定义），否则你的程序很可能是非确定性的。如果您没有足够的同步或并发控制，则以下是禁忌：

- 在两个线程之间访问任何形式的共享资源。
- 在非VCL线程中使用VCL的线程不安全部分。
- 试图在单独的线程中进行图形操作。

即使做两个线程访问共享整数变量这样简单的事情也可能导致完全的灾难

#### 4. 终止问题

与任何其他Delphi对象一样，线程涉及内存和资源分配，因此毫不奇怪地知道正常处理线程终止很重要，解除分配问题有两种可能的方法。

第一个是让线程自己处理问题。这主要用于以下任何一种线程：

- 在终止之前将线程执行结果传回主VCL线程。

- 在终止时不包含对其他线程有用的任何信息。

在这些情况下，程序员可以在线程对象中设置“FreeOnTerminate”标志，并在完成后自行处理。

第二种是让主VCL线程在完成后从工作线程对象读取数据，然后处理工作线程
##### 4.1. OnTerminate事件

当线程真正完成执行时，会发生OnTerminate事件。它并没有在终止线程的方法被调用发生。此事件可能非常有用，因为它在主VCL线程的上下文中执行，就像传递给同步的方法一样。因此，如果一个人希望用一个在终止时自动释放自己的线程来执行一些VCL操作，那么这就是它的地方。大多数线程新手都会发现这是获得非VCL线程将其数据传回VCL的最有用方法，只需要少量工作，并且不需要任何显式同步调用。

![mark](http://p5erjqv72.bkt.clouddn.com/coder16/180928/chmd4B7Fi2.png?imageslim)


从上图中可以看出，OnTerminate的工作方式与Synchronize的工作方式大致相同，并且在语义上几乎完全相同，即在线程结束时调用Synchronize。这主要用于通过在主VCL线程中使用诸如“AppCanQuit”之类的标志或运行线程的引用计数，可以提供一个简单的机制来确保主VCL线程仅在所有其他线程退出时已经退出了。这里涉及到同步细微之处，特别是如果程序员将对Application.Terminate的调用放入线程的OnTerminate事件中